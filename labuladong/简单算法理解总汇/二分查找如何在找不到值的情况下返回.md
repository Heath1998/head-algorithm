#   二分查找如何在找不到值的情况下返回



>  我们经常会使用二分查找，但是一般是找不到结果的，那怎么确定返回卡在中间的那个数的位置呢，
>
> 比如[1,3,5],找4，那返回位置1，还是2，这是个问题。比如想返回最长递增子序列那就只能4替换5了。





##   基础二分查找

```js
function test2(arr,target) {
  var left = 0,right =arr.length-1;
  var mid;
  while(left < right) {
    mid = Math.floor((left+right)/2);
    if(arr[mid] > target) {
      right = mid-1;
    } else if(arr[mid] < target){
      left = mid + 1;
    } else {
        return mid;
    }
  }
  return -1;
}
```

这里没什么用一般用不到。



##  值不相等的二分查找

```js
function test(arr,target) {
  var left = 0,right =arr.length-1;
  var mid;
  while(left < right) {
    mid = Math.floor((left+right)/2);
    if(arr[mid] >= target) {
      right = mid;
    } else {
      left = mid + 1;
    }
  }
  return left;
}
```

像这个函数我们不会去让它right的mid-1，这样的话可以控制只能left增长1好理解。

我就认真分析一下，但值不存在时，肯定left和right差值为1，如假设，`arr[left]<target<arr[right]`那因为向下取整得mid肯定会让left = mid+1;，此时left===right，那我们就可以控制返回什么了。



那这样返回left就是大于target得位置，返回left-1就是小于target得位置。



当然上面是当重复情况下找最左边得元素的。



```js
function test2(arr,target) {
  var left = 0,right =arr.length-1;
  var mid;
  while(left < right) {
    mid = Math.floor((left+right)/2);
    if(arr[mid] > target) {
      right = mid;
    } else {
      left = mid + 1;
    }
  }
  return left-1;
}
```



这个就是重复元素下找最右边的元素的。



##  死记住吧

