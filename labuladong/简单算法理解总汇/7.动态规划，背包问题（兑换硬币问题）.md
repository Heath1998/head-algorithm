#  7.动态规划，背包问题（兑换硬币问题）



> 还是一样先讲思想，做这些题目主要还是需要思路的，普通0-1背包就是前i个在j的体积可以拿到的最大值。无非就`dp[i-1][j-val[i-1]]`和`dp[i-1][j]`
>
> 如果是可以多选`dp[i][j-val[i-1]]`和`dp[i-1][j]`



##   1. 完全背包相关

###   1兑换硬币

```js
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
```

直接dp[i]代表当前钱为i时，最少硬币数，不可以的话就-1.

利用一个每一层`Math.min(比较每一个coins)`,`dp[i]`= `Math.min(dp[i-coins[j]]+1)`。记得用min=最大值测试下。



###  2兑换硬币2

```js
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 
```



同样用`dp[i][j]`代表前i个硬币下，钱为j有几种方式。默认`dp[i][0]=1`.

之后当前的`dp[i][j] = dp[i-1][j] +dp[i][j-coins[i-1]]`.

就是等于前i-1个硬币的筹的总数，在加上当前硬币下筹得总数。



##  2. 这0-1背包问题

```js
 dp[i][w] = max(dp[i - 1][w - wt[i-1]] + val[i-1], 
                               dp[i - 1][w]);
```



##  3.0-1变体

给定一个**只包含正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。



这种分三个还是4个用贪心。

从大到小排序，分进对应得容器，从4个找最小得放进去，这样一直循环，他们得差距就是最小了。